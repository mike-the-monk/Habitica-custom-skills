// This code is licensed under the same terms as Habitica:
  // https://raw.githubusercontent.com/HabitRPG/habitrpg/develop/LICENSE

/* ========================================== */
/* [Users] Required script data to fill in    */
/* ========================================== */
const USER_ID = "PasteYourUserIdHere";
const API_TOKEN = "PasteYourApiTokenHere"; // Do not share this to anyone
const WEB_APP_URL = "PasteGeneratedWebAppUrlHere";

/* ========================================== */
/* [Users] Required customizations to fill in */
/* ========================================== */

// For each skill you want to add, change the 0 to a 1. If you don't want it, keep it as a 0

const CREATE_PICKPOCKET = 0; // Gain GP based on Perception. 15 MP. Unlocks at level 11.
const CREATE_BACKSTAB = 0; // Gain GP and XP based on Strength. 20 MP. Unlocks at level 12.
const CREATE_STEALTH = 0; // Take no damage from some undone Dailies, based on Perception. 50 MP. Unlocks at level 14.
const CREATE_HEALING_LIGHT = 0; // Gain HP based on Intelligence and Constitution. 20 MP. Unlocks at level 11.
const CREATE_CHILLING_FROST = 0; // Freeze streaks of all Dailies so they don't reset if incomplete. 45 MP. Unlocks at level 14.
const CREATE_BURST_OF_FLAMES_XP_ONLY = 0; // Gain XP based on Intelligence. 10 MP. Unlocks at level 11.
const CREATE_BURST_OF_FLAMES_DAMAGE_ONLY = 0; // Deal boss damage based on Intelligence. 10 MP per use, multi-use only (to deal 90+ damage). Unlocks at level 11.
const CREATE_BURST_OF_FLAMES_XP_PLUS_DAMAGE = 0; // Deal boss damage and gain XP based on Intelligence. 15 MP per use, multi-use only (to deal 90+ damage). Unlocks at level 11.
const CREATE_BRUTAL_SMASH = 0; // Deal boss damage based on Strength. 10 MP per use, multi-use only (to deal 90+ damage). Unlocks at level 11. 
const CREATE_RADIANT_SHIELD = 0; // Deal boss damage based on Constitution. 7.5 MP per use, multi-use only (to deal 90+ damage). Unlocks at level 11.
const CREATE_SNEAK_ATTACK = 0; // Deal boss damage based on Perception. 10 MP per use, multi-use only (to deal 90+ damage). Unlocks at level 11.


// Which version of the skill do you want to use? (you can do the same or different for each skill)
// Choose 2 if you want to set a task value and use it rather than using a specific task.
// Choose 3 if you want to average the task values of all your Dailies and use that.
// Choose 4 if you want to select one task and always use that task with this skill.

const PICKPOCKET_VERSION = 2;
const BACKSTAB_VERSION = 2;
const BURST_OF_FLAMES_VERSION = 2;


// Based on the version you picked, scroll to the relevant section below



// If you picked version 2 for any of them, select what task value you want to use
// For example, a green task can have a task value between 1 and 5
// A light blue task and have a task value between 6 and 11
// A bright blue task has a value above 12
// The maximum task value is 21.27

const PICKPOCKET_TASK_VALUE = 10;
const BACKSTAB_TASK_VALUE = 10;
const BURST_OF_FLAMES_TASK_VALUE = 10;


// If you picked version 3 for any of them, you don't have to do anything else in this section.


// If you picked version 4 for any of them, find the task ID of the task you want to use and paste below
// Instructions for this are found in the wiki page

const PICKPOCKET_TASK_ID = "620dc42a-b258-47a9-84fa-a5c437345a9";
const BACKSTAB_TASK_ID = "620dc42a-b258-47a9-84fa-a5c437345a9";
const BURST_OF_FLAMES_TASK_ID = "620dc42a-b258-47a9-84fa-a5c437345a9";




/* ========================================== */
/* [Users] Optional customizations to fill in */
/* ========================================== */

// Do you want to get private message notifications for having insufficient mana or being too low of a level to use the skill?
// If you don't want them, change the 1 to a 0 in the line below
const NOTIFICATIONS_ON = 1; 

/* ========================================== */
/* [Users] Do not edit code below this line   */
/* ========================================== */
const AUTHOR_ID = "0034eb14-b4d8-494e-8386-d3f33cff7922";
const SCRIPT_NAME = "Cross-Class Skills";
const HEADERS = {
  "x-client" : AUTHOR_ID + " - " + SCRIPT_NAME,
  "x-api-user" : USER_ID,
  "x-api-key" : API_TOKEN,
}

const scriptProperties = PropertiesService.getScriptProperties(); // Constants can have properties changed

const LEVEL_LOCK_PICKPOCKET = 11;
const LEVEL_LOCK_BACKSTAB = 12;
const LEVEL_LOCK_STEALTH = 14;
const LEVEL_LOCK_HEALING_LIGHT = 11;
const LEVEL_LOCK_CHILLING_FROST = 14;
const LEVEL_LOCK_BURST_OF_FLAMES = 11;
const LEVEL_LOCK_BRUTAL_SMASH = 11;
const LEVEL_LOCK_RADIANT_SHIELD = 11;
const LEVEL_LOCK_SNEAK_ATTACK = 11;

const MP_COST_PICKPOCKET = 15;
const MP_COST_BACKSTAB = 20;
const MP_COST_STEALTH = 50;
const MP_COST_HEALING_LIGHT = 20;
const MP_COST_CHILLING_FROST = 45;
const MP_COST_BURST_OF_FLAMES_XP_ONLY = 10;
const MP_COST_BURST_OF_FLAMES_DAMAGE_ONLY = 10;
const MP_COST_BURST_OF_FLAMES_XP_PLUS_DAMAGE = 15;
const MP_COST_BRUTAL_SMASH = 10;
const MP_COST_RADIANT_SHIELD = 7.5;
const MP_COST_SNEAK_ATTACK = 10;

const PICKPOCKET_TEXT = "**Cross-Class Pickpocket**";
const PICKPOCKET_ALIAS = "ccPickpocket";
const PICKPOCKET_NOTES = "You rob a nearby task and gain gold! (Based on: PER). 15 MP.";
const PICKPOCKET_VALUE = "0";

const PICKPOCKET_BUTTON = {
    "text": PICKPOCKET_TEXT,
    "type": "reward",
    "alias": PICKPOCKET_ALIAS,
    "notes": PICKPOCKET_NOTES,
    "value": PICKPOCKET_VALUE,
}

const BACKSTAB_TEXT = "**Cross-Class Backstab**";
const BACKSTAB_ALIAS = "ccBackstab";
const BACKSTAB_NOTES = "You betray a foolish task and gain gold and XP! (Based on: STR). 20 MP.";
const BACKSTAB_VALUE = "0";

const BACKSTAB_BUTTON = {
    "text": BACKSTAB_TEXT,
    "type": "reward",
    "alias": BACKSTAB_ALIAS,
    "notes": BACKSTAB_NOTES,
    "value": BACKSTAB_VALUE,
}

const STEALTH_TEXT = "**Cross-Class Stealth**";
const STEALTH_ALIAS = "ccStealth";
const STEALTH_NOTES = "With each cast, a few of your undone Dailies won't cause damage tonight. Their streaks and colors won't change. (Based on: PER) (Cast multiple times to affect more Dailies.). 50 MP.";
const STEALTH_VALUE = "0";

const STEALTH_BUTTON = {
    "text": STEALTH_TEXT,
    "type": "reward",
    "alias": STEALTH_ALIAS,
    "notes": STEALTH_NOTES,
    "value": STEALTH_VALUE,
}

const HEALING_LIGHT_TEXT = "**Cross-Class Healing Light**";
const HEALING_LIGHT_ALIAS = "ccHealingLight";
const HEALING_LIGHT_NOTES = "Shining light restores your health! (Based on: CON and INT). 20 MP.";
const HEALING_LIGHT_VALUE = "0";

const HEALING_LIGHT_BUTTON = {
    "text": HEALING_LIGHT_TEXT,
    "type": "reward",
    "alias": HEALING_LIGHT_ALIAS,
    "notes": HEALING_LIGHT_NOTES,
    "value": HEALING_LIGHT_VALUE,
}

const CHILLING_FROST_TEXT = "**Cross-Class Chilling Frost**";
const CHILLING_FROST_ALIAS = "ccChillingFrost";
const CHILLING_FROST_NOTES = "With one cast, ice freezes all your streaks so they won't reset to zero tomorrow! 45 MP.";
const CHILLING_FROST_VALUE = "0";

const CHILLING_FROST_BUTTON = {
    "text": CHILLING_FROST_TEXT,
    "type": "reward",
    "alias": CHILLING_FROST_ALIAS,
    "notes": CHILLING_FROST_NOTES,
    "value": CHILLING_FROST_VALUE,
}

const BURST_OF_FLAMES_XP_ONLY_TEXT = "**Cross-Class Burst of Flames (XP only, single use)**";
const BURST_OF_FLAMES_XP_ONLY_ALIAS = "ccBurstOfFlamesXp";
const BURST_OF_FLAMES_XP_ONLY_NOTES = "You summon fiery XP! (Based on: INT). 10 MP.";
const BURST_OF_FLAMES_XP_ONLY_VALUE = "0";

const BURST_OF_FLAMES_XP_ONLY_BUTTON = {
    "text": BURST_OF_FLAMES_XP_ONLY_TEXT,
    "type": "reward",
    "alias": BURST_OF_FLAMES_XP_ONLY_ALIAS,
    "notes": BURST_OF_FLAMES_XP_ONLY_NOTES,
    "value": BURST_OF_FLAMES_XP_ONLY_VALUE,
}

const BURST_OF_FLAMES_DAMAGE_ONLY_TEXT = "**Cross-Class Burst of Flames (Damage only, multi-use)**";
const BURST_OF_FLAMES_DAMAGE_ONLY_ALIAS = "ccBurstOfFlamesDamage";
const BURST_OF_FLAMES_DAMAGE_ONLY_NOTES = "You summon a burst of fiery damage to Bosses! (Based on: INT). 10 MP per use.";
const BURST_OF_FLAMES_DAMAGE_ONLY_VALUE = "0";

const BURST_OF_FLAMES_DAMAGE_ONLY_BUTTON = {
    "text": BURST_OF_FLAMES_DAMAGE_ONLY_TEXT,
    "type": "reward",
    "alias": BURST_OF_FLAMES_DAMAGE_ONLY_ALIAS,
    "notes": BURST_OF_FLAMES_DAMAGE_ONLY_NOTES,
    "value": BURST_OF_FLAMES_DAMAGE_ONLY_VALUE,
}

const BURST_OF_FLAMES_XP_PLUS_DAMAGE_TEXT = "**Cross-Class Burst of Flames (XP and damage, multi-use)**";
const BURST_OF_FLAMES_XP_PLUS_DAMAGE_ALIAS = "ccBurstOfFlamesBoth";
const BURST_OF_FLAMES_XP_PLUS_DAMAGE_NOTES = "You summon a burst of flames and deal fiery damage to Bosses! (Based on: INT). 15 MP per use.";
const BURST_OF_FLAMES_XP_PLUS_DAMAGE_VALUE = "0";

const BURST_OF_FLAMES_XP_PLUS_DAMAGE_BUTTON = {
    "text": BURST_OF_FLAMES_XP_PLUS_DAMAGE_TEXT,
    "type": "reward",
    "alias": BURST_OF_FLAMES_XP_PLUS_DAMAGE_ALIAS,
    "notes": BURST_OF_FLAMES_XP_PLUS_DAMAGE_NOTES,
    "value": BURST_OF_FLAMES_XP_PLUS_DAMAGE_VALUE,
}

const BRUTAL_SMASH_TEXT = "**Cross-Class Brutal Smash (damage only, multi-use)**";
const BRUTAL_SMASH_ALIAS = "ccBrutalSmash";
const BRUTAL_SMASH_NOTES = "You deal extra damage to Bosses! (Based on: STR). 10 MP per use.";
const BRUTAL_SMASH_VALUE = "0";

const BRUTAL_SMASH_BUTTON = {
    "text": BRUTAL_SMASH_TEXT,
    "type": "reward",
    "alias": BRUTAL_SMASH_ALIAS,
    "notes": BRUTAL_SMASH_NOTES,
    "value": BRUTAL_SMASH_VALUE,
}

const RADIANT_SHIELD_TEXT = "**Radiant Shield (multi-use)**";
const RADIANT_SHIELD_ALIAS = "ccRadiantShield";
const RADIANT_SHIELD_NOTES = "A burst of light redirects some of your foes' attack back on them! Deals boss damage (Based on: CON). 7.5 MP per use.";
const RADIANT_SHIELD_VALUE = "0";

const RADIANT_SHIELD_BUTTON = {
    "text": RADIANT_SHIELD_TEXT,
    "type": "reward",
    "alias": RADIANT_SHIELD_ALIAS,
    "notes": RADIANT_SHIELD_NOTES,
    "value": RADIANT_SHIELD_VALUE,
}

const SNEAK_ATTACK_TEXT = "**Sneak Attack (multi-use)**";
const SNEAK_ATTACK_ALIAS = "ccSneakAttack";
const SNEAK_ATTACK_NOTES = "Your keen eyes notice a weak spot and deal damage to Bosses! (Based on: PER). 10 MP per use. ";
const SNEAK_ATTACK_VALUE = "0";

const SNEAK_ATTACK_BUTTON = {
    "text": SNEAK_ATTACK_TEXT,
    "type": "reward",
    "alias": SNEAK_ATTACK_ALIAS,
    "notes": SNEAK_ATTACK_NOTES,
    "value": SNEAK_ATTACK_VALUE,
}

const DAMAGE_TEXT = "Boss damage";
const DAMAGE_NOTES = "used to create boss damage as part of a custom script";

const DAMAGE_BUTTON = {
    "text": DAMAGE_TEXT,
    "type": "todo",
    "notes": DAMAGE_NOTES,
    "priority": 0.1,
}

const TIMESTAMP_KEY = "TIMESTAMP_KEY";
var timestampKey = "";

function doOneTimeSetup() {
  // These are not "else if" statements on purpose
  if (CREATE_SNEAK_ATTACK == 1) {
    api_createNewTaskForUser([SNEAK_ATTACK_BUTTON]);
  }
  if (CREATE_RADIANT_SHIELD == 1) {
    api_createNewTaskForUser([RADIANT_SHIELD_BUTTON]);
  }
  if (CREATE_BRUTAL_SMASH == 1) {
    api_createNewTaskForUser([BRUTAL_SMASH_BUTTON]);
  }
  if (CREATE_BURST_OF_FLAMES_XP_PLUS_DAMAGE == 1) {
    api_createNewTaskForUser([BURST_OF_FLAMES_XP_PLUS_DAMAGE_BUTTON]);
  }
  if (CREATE_BURST_OF_FLAMES_DAMAGE_ONLY == 1) {
    api_createNewTaskForUser([BURST_OF_FLAMES_DAMAGE_ONLY_BUTTON]);
  }
  if (CREATE_BURST_OF_FLAMES_XP_ONLY == 1) {
    api_createNewTaskForUser([BURST_OF_FLAMES_XP_ONLY_BUTTON]);
  }
  if (CREATE_CHILLING_FROST == 1) {
    api_createNewTaskForUser([CHILLING_FROST_BUTTON]);
  }
  if (CREATE_HEALING_LIGHT == 1) {
    api_createNewTaskForUser([HEALING_LIGHT_BUTTON]);
  }
  if (CREATE_STEALTH == 1) {
    api_createNewTaskForUser([STEALTH_BUTTON]);
  }
  if (CREATE_BACKSTAB == 1) {
    api_createNewTaskForUser([BACKSTAB_BUTTON]);
  }
  if (CREATE_PICKPOCKET == 1) {
    api_createNewTaskForUser([PICKPOCKET_BUTTON]);
  }
  
  // Next, create the webhook
  const options = {
    "scored" : true,
  }
  const payload = {
    "url" : WEB_APP_URL,
    "label" : SCRIPT_NAME + " Webhook",
    "type" : "taskActivity",
    "options" : options,
  }
  apiMult_createNewWebhookNoDuplicates(payload);
  
  // set script properties so they carry over to next session
  initScriptProperties();
}

// do things when the webhook runs
function doPost(e) {
  const dataContents = JSON.parse(e.postData.contents);
  const type = dataContents.type;
  const task = dataContents.task;
  
  // Sanitize task alias
  if ((task.alias == undefined) || (task.alias == null)) {
    task.alias = "";
  }
  if (type == "scored") {
    // Check if the alias matches any of them
    if ( (task.alias == PICKPOCKET_ALIAS) || (task.alias == BACKSTAB_ALIAS) || (task.alias == STEALTH_ALIAS) 
      || (task.alias == HEALING_LIGHT_ALIAS) || (task.alias == CHILLING_FROST_ALIAS)
      || (task.alias == BURST_OF_FLAMES_XP_ONLY_ALIAS) || (task.alias == BURST_OF_FLAMES_DAMAGE_ONLY_ALIAS) 
      || (task.alias == BURST_OF_FLAMES_XP_PLUS_DAMAGE_ALIAS) || (task.alias == BRUTAL_SMASH_ALIAS) 
      || (task.alias == RADIANT_SHIELD_ALIAS) || (task.alias == SNEAK_ATTACK_ALIAS) ) {
      
      var timestampKey = TIMESTAMP_KEY;
      var timeStart = Number(scriptProperties.getProperty(timestampKey));
      if ( (timeStart == 0) || (timeStart == "") || (timeStart == undefined) || (timeStart == null) ) {
        timeStart = Date.now();
      }
      var timeEnd = Date.now();
      
      // Rate limiting: If it's been less than 30 seconds since they last clicked one of these buttons, do nothing
      if ( (timeEnd - timeStart) >= 30000 ) {
      
        // Get user info
        const responseUser = api_getAuthenticatedUserProfile("stats,tasksOrder,items.gear.equipped");
        user = JSON.parse(responseUser).data;

        // Get equipment stats info
        const responseContent = apiFree_getAllAvailableContentObjects();
        content = JSON.parse(responseContent).data;
        
        var lvl = user.stats.lvl;
        var mp = user.stats.mp;
        var hp = user.stats.hp;
        var xp = user.stats.exp;
        var gp = user.stats.gp;
        
        var totalDailies = user.tasksOrder.dailys.length;
        var stealthedDailies = user.stats.buffs.stealth;
        if (!user.stats.buffs.stealth) stealthedDailies = 0;
        var frostCast = user.stats.buffs.streaks;
        
        var strength = calculateStrength();      
        var intelligence = calculateIntelligence();
        var constitution = calculateConstitution();     
        var perception = calculatePerception();
        
        var buffsStr = user.stats.buffs.str;
        if (!user.stats.buffs.str) buffsStr = 0;
        var buffsInt = user.stats.buffs.int;
        if (!user.stats.buffs.int) buffsInt = 0;
        var buffsCon = user.stats.buffs.con;
        if (!user.stats.buffs.con) buffsCon = 0;
        var buffsPer = user.stats.buffs.per;
        if (!user.stats.buffs.per) buffsPer = 0;
        
        var unbuffedStr = strength - buffsStr;
        var unbuffedInt = intelligence - buffsInt;
        var unbuffedCon = constitution - buffsCon;
        var unbuffedPer = perception - buffsPer;
                
        // Check which alias it is. Then, check level lock and mana.
        if (task.alias == PICKPOCKET_ALIAS) {
          if ( lvl < LEVEL_LOCK_PICKPOCKET ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {       
            var enoughMana = checkMana(mp, MP_COST_PICKPOCKET);
            if (enoughMana) {
              pickpocket(gp, perception);
            }
          }
        }
        else if (task.alias == BACKSTAB_ALIAS) {
          if ( lvl < LEVEL_LOCK_BACKSTAB  ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 12 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            var enoughMana = checkMana(mp, MP_COST_BACKSTAB);
            if (enoughMana) {
              backstab(gp, xp, strength);
            }
          }
        }
        else if (task.alias == STEALTH_ALIAS) {
          if ( lvl < LEVEL_LOCK_STEALTH  ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 14 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // Check how many Dailies due but aren't complete
            const responseTaskStealth = api_getUserTasks("dailys");
            const tasksStealth = JSON.parse(responseTaskStealth).data;
            var tasksDueAndNotComplete = 0;
            
            for (var i in tasksStealth) {
              if ( (tasksStealth[i].isDue == true)  && (tasksStealth[i].completed == false) ) {
                tasksDueAndNotComplete++;
              }
            }
            
            // If already avoided all dailies that are due but not complete, send message and don't subtract MP cost
            if (stealthedDailies >= tasksDueAndNotComplete){
              api_sendPrivateMessageAlways({"message" : "You've already avoided all your Dailies, so additional uses of this skill have no effect.", "toUserId" : USER_ID});
            }
            // Do skill as normal
            else {
              var enoughMana = checkMana(mp, MP_COST_STEALTH);
              if (enoughMana) {
                stealth (totalDailies, stealthedDailies, perception);
              }
            }
          }
        }
        else if (task.alias == HEALING_LIGHT_ALIAS) {
          if ( lvl < LEVEL_LOCK_HEALING_LIGHT ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // If not at max HP, subtract mana cost and do the skill
            if (hp < 50) {
              var enoughMana = checkMana(mp, MP_COST_HEALING_LIGHT);
              if (enoughMana) {
                healingLight (hp, constitution, intelligence);
              }
            }
            else { // if already at max HP, do nothing
              api_sendPrivateMessage({"message" : "You are already at max HP.", "toUserId" : USER_ID});
            }
          }
        }
        else if (task.alias == CHILLING_FROST_ALIAS) {
          if ( lvl < LEVEL_LOCK_CHILLING_FROST  ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 14 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            var enoughMana = checkManaDeductLater(mp, MP_COST_CHILLING_FROST);
            if (enoughMana) {
              // Check if already cast, send message if yes
              if (frostCast == true){
                api_sendPrivateMessageAlways({"message" : "You've already used this skill. Additional uses have no effect.", "toUserId" : USER_ID});
              }
              else {
                chillingFrost(mp, MP_COST_CHILLING_FROST); // includes deducting MP cost
              }
            }
          }
        }
        else if (task.alias == BURST_OF_FLAMES_XP_ONLY_ALIAS) {
          if ( lvl < LEVEL_LOCK_BURST_OF_FLAMES  ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            var enoughMana = checkMana(mp, MP_COST_BURST_OF_FLAMES_XP_ONLY);
            if (enoughMana) {
              var xpGain = burstOfFlamesXp(intelligence, perception, 1); 
              api_updateUser({"stats.exp" : xp + xpGain});
            }
          }
        }
        else if (task.alias == BURST_OF_FLAMES_DAMAGE_ONLY_ALIAS) {
          if ( lvl < LEVEL_LOCK_BURST_OF_FLAMES  ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // Check how much damage it will deal once, and then whether they have enough MP for multi-use (to exceed 90.71 damage)
            var damageOnce = flamesDamage(intelligence);
            var numberTimes = checkManaMultiUse(mp, MP_COST_BURST_OF_FLAMES_DAMAGE_ONLY, damageOnce, false, intelligence, perception);
            
            // If mana is sufficient
            if (numberTimes > 0) {
              var damageDealt = damageOnce * numberTimes;
              doDamage(damageDealt, MP_COST_BURST_OF_FLAMES_DAMAGE_ONLY, numberTimes, unbuffedStr, unbuffedInt, unbuffedPer, buffsStr, buffsInt, buffsPer, hp, xp, mp, gp, lvl, false, 0);
            }
          }
        }
        else if (task.alias == BURST_OF_FLAMES_XP_PLUS_DAMAGE_ALIAS) {
          if ( lvl < LEVEL_LOCK_BURST_OF_FLAMES ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // Check how much damage it will deal once, and then whether they have enough MP for multi-use (to exceed 90.71 damage)
            var damageOnce = flamesDamage(intelligence);
            var numberTimes = checkManaMultiUse(mp, MP_COST_BURST_OF_FLAMES_XP_PLUS_DAMAGE, damageOnce, true, intelligence, perception);
            
            // If mana is sufficient
            if (numberTimes > 0) {
              var xpGain = burstOfFlamesXp(intelligence, perception, numberTimes);
              var damageDealt = damageOnce * numberTimes;
              doDamage(damageDealt, MP_COST_BURST_OF_FLAMES_XP_PLUS_DAMAGE, numberTimes, unbuffedStr, unbuffedInt, unbuffedPer, buffsStr, buffsInt, buffsPer, hp, xp, mp, gp, lvl, true, xpGain);
            }
          }
        }
        else if (task.alias == BRUTAL_SMASH_ALIAS) {
          if ( lvl < LEVEL_LOCK_BRUTAL_SMASH ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // Check how much damage it will deal once, and then whether they have enough MP for multi-use (to exceed 90.71 damage)
            var damageOnce = smashDamageNoCrit(strength);
            var numberTimes = checkManaMultiUse(mp, MP_COST_BRUTAL_SMASH, damageOnce, false, intelligence, perception);
            
            // If mana is sufficient
            if (numberTimes > 0) {
              var damageDealt = smashDamageActual(strength, constitution, numberTimes);
              doDamage(damageDealt, MP_COST_BRUTAL_SMASH, numberTimes, unbuffedStr, unbuffedInt, unbuffedPer, buffsStr, buffsInt, buffsPer, hp, xp, mp, gp, lvl, false, 0);
            }
          }
        }
        else if (task.alias == RADIANT_SHIELD_ALIAS) {
          if ( lvl < LEVEL_LOCK_RADIANT_SHIELD ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // Check how much damage it will deal once, and then whether they have enough MP for multi-use (to exceed 90.71 damage)
            var damageOnce = radiantDamageNoCrit(constitution);
            var numberTimes = checkManaMultiUse(mp, MP_COST_RADIANT_SHIELD, damageOnce, false, intelligence, perception);
            
            // If mana is sufficient
            if (numberTimes > 0) {
              var damageDealt = radiantDamageActual(constitution, intelligence, numberTimes);
              doDamage(damageDealt, MP_COST_RADIANT_SHIELD, numberTimes, unbuffedStr, unbuffedInt, unbuffedPer, buffsStr, buffsInt, buffsPer, hp, xp, mp, gp, lvl, false, 0);
            }
          }
        }
        else if (task.alias == SNEAK_ATTACK_ALIAS) {
          if ( lvl < LEVEL_LOCK_SNEAK_ATTACK ) {
            api_sendPrivateMessage({"message" : "Insufficient level: you must be at least level 11 to use this skill.", "toUserId" : USER_ID});
          }
          else {
            // Check how much damage it will deal once, and then whether they have enough MP for multi-use (to exceed 90.71 damage)
            var damageOnce = sneakDamageNoCrit(perception);
            var numberTimes = checkManaMultiUse(mp, MP_COST_SNEAK_ATTACK, damageOnce, false, intelligence, perception);
            
            // If mana is sufficient
            if (numberTimes > 0) {
              var damageDealt = sneakDamageActual(perception, strength, numberTimes);
              doDamage(damageDealt, MP_COST_SNEAK_ATTACK, numberTimes, unbuffedStr, unbuffedInt, unbuffedPer, buffsStr, buffsInt, buffsPer, hp, xp, mp, gp, lvl, false, 0);
            }
          }
        }
        
        // Save values to non-volatile memory, but only from within the rate-limited if-block (we don't want to save the timestamp unless the script ran)
        timeStart = timeEnd;
        scriptProperties.setProperty(timestampKey, timeStart);
      }
    }
  }
  
  return HtmlService.createHtmlOutput();
}

// Create custom reward buttons
function api_createNewTaskForUser(payload) {
  var params = {
    "method" : "post",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload), // Rightmost button goes on top
    "muteHttpExceptions" : true,
  }

  var url = "https://habitica.com/api/v3/tasks/user";
  UrlFetchApp.fetch(url, params);
}

// Create a webhook if no duplicate exists
function apiMult_createNewWebhookNoDuplicates(payload) {
  const response = api_getWebhooks();
  const webhooks = JSON.parse(response).data;
  var duplicateExists = 0;
    
  for (var i in webhooks) {
    if (webhooks[i].label == payload.label) {
      duplicateExists = 1;
    }
  }
  // If webhook to be created doesn't exist yet
  if (!duplicateExists) {
    api_createNewWebhook(payload);
  }
}

// Used to see existing webhooks, and therefore if there's a duplicate
function api_getWebhooks() {
  const params = {
    "method" : "get",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }
  
  const url = "https://habitica.com/api/v3/user/webhook";
  return UrlFetchApp.fetch(url, params);
}

// Creates a webhook (as part of the "don't make it if there's a duplicate" function)
function api_createNewWebhook(payload) {
  const params = {
    "method" : "post",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload),
    "muteHttpExceptions" : true,
  }
   
  const url = "https://habitica.com/api/v3/user/webhook";
  return UrlFetchApp.fetch(url, params);
}

// Sets initial properties that will be used/saved later.
function initScriptProperties() {
  var timestampInit = Date.now();
  scriptProperties.setProperty(TIMESTAMP_KEY, timestampInit);
}

// Gets user info so I can use it, especially stats like mana, experience, and level
function api_getAuthenticatedUserProfile(userFields) {
  const params = {
    "method" : "get",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }
  
  var url = "https://habitica.com/api/v3/user";
  if (userFields != "") {
    url += "?userFields=" + userFields;
  }

  return UrlFetchApp.fetch(url, params);
}

function apiFree_getAllAvailableContentObjects() {
  const params = {
    "method" : "get",
    "muteHttpExceptions" : true,
  }
  
  const url = "https://habitica.com/api/v3/content";
  return UrlFetchApp.fetch(url, params);
}


// Send a notification as a private message, only if they're enabled
function api_sendPrivateMessage(payload) {
  switch (NOTIFICATIONS_ON){ // Check if notifications are on, send message if yes
    case 0:
      break;        
    case 1:
      const params = {
        "method" : "post",
        "headers" : HEADERS,
        "contentType" : "application/json",
        "payload" : JSON.stringify(payload),
        "muteHttpExceptions" : true,
      }
      const url = "https://habitica.com/api/v3/members/send-private-message";
      return UrlFetchApp.fetch(url, params);
    break;
  }
}

// Send a notification as a private message regardless of if they're enabled
function api_sendPrivateMessageAlways(payload) {
  const params = {
    "method" : "post",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload),
    "muteHttpExceptions" : true,
  }
  const url = "https://habitica.com/api/v3/members/send-private-message";
  return UrlFetchApp.fetch(url, params);
}

function calculateStrength() {
  const levelStr = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassStr = 0;
  const allocatedStr = user.stats.str;
  const buffsStr = user.stats.buffs.str;
  
  // Get STR from equipped gear
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassStr += calcEquipmentAndClassStr(content.gear.flat[user.items.gear.equipped.back]);

  return levelStr + totalEquipmentAndClassStr + allocatedStr + buffsStr;
}

function calcEquipmentAndClassStr(equipment) {
  var equipmentAndClassStr = 0;

  if (equipment != undefined) {  
    equipmentAndClassStr += equipment.str;
    if ( (equipment.klass == user.stats.class) || ( (equipment.klass == "special") && (equipment.specialClass == user.stats.class) ) ) {
      equipmentAndClassStr += equipment.str / 2;
    }
  }
  
  return equipmentAndClassStr;
}

function calculateIntelligence() {
  const levelInt = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassInt = 0;
  const allocatedInt = user.stats.int;
  const buffsInt = user.stats.buffs.int;

  // Get INT from equipped gear
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassInt += calcEquipmentAndClassInt(content.gear.flat[user.items.gear.equipped.back]);

  return levelInt + totalEquipmentAndClassInt + allocatedInt + buffsInt;
}

function calcEquipmentAndClassInt(equipment) {
  var equipmentAndClassInt = 0;

  if (equipment != undefined) {  
    equipmentAndClassInt += equipment.int;
    if ( (equipment.klass == user.stats.class) || ( (equipment.klass == "special") && (equipment.specialClass == user.stats.class) ) ) {
      equipmentAndClassInt += equipment.int / 2;
    }
  }
  
  return equipmentAndClassInt;
}

function calculateConstitution() {
  const levelCon = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassCon = 0;
  const allocatedCon = user.stats.con;
  const buffsCon = user.stats.buffs.con;
  
  // Get CON from equipped gear
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassCon += calcEquipmentAndClassCon(content.gear.flat[user.items.gear.equipped.back]);

  return levelCon + totalEquipmentAndClassCon + allocatedCon + buffsCon;
}

function calcEquipmentAndClassCon(equipment) {
  var equipmentAndClassCon = 0;

  if (equipment != undefined) {  
    equipmentAndClassCon += equipment.con;
    if ( (equipment.klass == user.stats.class) || ( (equipment.klass == "special") && (equipment.specialClass == user.stats.class) ) ) {
      equipmentAndClassCon += equipment.con / 2;
    }
  }
  
  return equipmentAndClassCon;
}

function calculatePerception() {
  const levelPer = Math.floor(user.stats.lvl / 2);
  var totalEquipmentAndClassPer = 0;
  const allocatedPer = user.stats.per;
  const buffsPer = user.stats.buffs.per;
  
  // Get PER from equipped gear
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.weapon]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.shield]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.head]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.armor]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.headAccessory]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.eyewear]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.body]);
  totalEquipmentAndClassPer += calcEquipmentAndClassPer(content.gear.flat[user.items.gear.equipped.back]);

  return levelPer + totalEquipmentAndClassPer + allocatedPer + buffsPer;
}

function calcEquipmentAndClassPer(equipment) {
  var equipmentAndClassPer = 0;

  if (equipment != undefined) {  
    equipmentAndClassPer += equipment.per;
    if ( (equipment.klass == user.stats.class) || ( (equipment.klass == "special") && (equipment.specialClass == user.stats.class) ) ) {
      equipmentAndClassPer += equipment.per / 2;
    }
  }
  
  return equipmentAndClassPer;
}

// Checks if sufficient mana, sends message if not, deduct cost if true
function checkMana(mp, mpCost){
  if (mp < mpCost) {
    api_sendPrivateMessage({"message" : "Insufficient mana to use this skill.", "toUserId" : USER_ID});
    return false;
  }
  else {
    api_updateUser({"stats.mp" : mp - mpCost});
    return true;
  }
}

// Checks if sufficient mana, sends message if not, does not deduct it now
function checkManaDeductLater(mp, mpCost){
  if (mp < mpCost) {
    api_sendPrivateMessage({"message" : "Insufficient mana to use this skill.", "toUserId" : USER_ID});
    return false;
  }
  else {
    return true;
  }
}

// How many uses of the skill are required to exceed 90.71 damage? At that damage or higher, crit is guaranteed and thus the script can accurately dial in damage
function checkManaMultiUse(mp, mpCost, damageOnce, isFlamesXp, int, per) {
  var numberTimes = Math.ceil(90.71/damageOnce);
  var damageMulti = damageOnce * numberTimes;
  var multiMpCost = mpCost * numberTimes;
  
  // If insufficient MP for multi use, send an error message including expected damage (and if Flames with XP, expected XP)
  if ( multiMpCost > mp ) {
    // round the damage to one decimal point (for the sake of the message)
    var damageMultiForMessage = Math.round(damageMulti*10) / 10;
    
    if (isFlamesXp) {
      var xpGain = burstOfFlamesXp(int, per, numberTimes); 
      api_sendPrivateMessage({"message" : "Insufficient Mana. You will need " + multiMpCost + " MP to use this skill, and it will do " + damageMultiForMessage + " damage and you will gain " + xpGain + " XP.", "toUserId" : USER_ID});
      return 0;
    }
    else {
      api_sendPrivateMessage({"message" : "Insufficient Mana. You will need " + multiMpCost + " MP to use this skill, and it will do " + damageMultiForMessage + " damage.", "toUserId" : USER_ID});
      return 0;
    }
  }
  else {
    return numberTimes;
  }
}

// Changes stats
function api_updateUser(payload) { 
  const params = {
    "method" : "put",
    "headers" : HEADERS,
    "contentType" : "application/json",
    "payload" : JSON.stringify(payload),
    "muteHttpExceptions" : true,
  }
  
  const url = "https://habitica.com/api/v3/user";
  return UrlFetchApp.fetch(url, params);
}

function getTaskValue(version, presetTaskValue, taskId) {
  switch (version){
    case 2:
      var value = sanitizeTaskValue(presetTaskValue);
      return value;
      break;        
    case 3:
      const responseV3 = api_getUserTasks("dailys");
      const tasksV3 = JSON.parse(responseV3).data;
      
      // loop over all Dailies, then average the task value
      var taskCount = 0;
      var taskValueTotal = 0;
      for (var i in tasksV3) {
        taskValueTotal += tasksV3[i].value;
        taskCount++;
      }
      var average = sanitizeTaskValue(taskValueTotal/taskCount);
      return average;
      break;
    case 4:
      const responseV4 = api_getUserTasks("dailys");
      const tasksV4 = JSON.parse(responseV4).data;
      var valueV4 = -100;
          
      for (var j in tasksV4) {
        if (tasksV4[j]._id == taskId) {
          valueV4 = tasksV4[j].value;
        }
      }
      
      if (valueV4 == -100) {
        api_sendPrivateMessageAlways({"message" : "Task ID not found, so this script defaulted to the preset task value (version 2 in the Required Customization section). To find task value, see the [wiki page](https://habitica.fandom.com/wiki/Google_Apps_Script#Cross-Class_Skills) section on Required Customizations and then update the script using the instructions at the bottom of the wiki page.", "toUserId" : USER_ID});
        var valueIfError = sanitizeTaskValue(presetTaskValue);
        return valueIfError;
         break;
      }
      else {
        // grab value of task ID
        var valueById = sanitizeTaskValue(valueV4);
        return valueById;
        break;
      }
  }
}

function sanitizeTaskValue(value) {
  if (value < 0) {
    return 0;
  }
  else if (value > 21.27) {
    return 21.27;
  }
  else {
    return value;
  }
}

function criticalHit (stat, chance) {
  var targetToBeat = chance * ( (1 + stat ) / 100 );
  if (Math.random() <= targetToBeat) {
    return (1.5 +  ( 4 * stat ) / ( stat + 200 ) );
  }
  else {
    return 1;
  }
}

function pickpocket (gp, per) {
  var taskValue = getTaskValue(PICKPOCKET_VERSION, PICKPOCKET_TASK_VALUE, PICKPOCKET_TASK_ID);
  var bonus = ( (taskValue + 1) + (per * 0.5 ) );
  var newGp = gp + ( ( 25 * bonus ) / ( bonus + 75) );
  
  api_updateUser({"stats.gp" : newGp});
}

function backstab (gp, xp, str) {
  var multiplier = criticalHit(str, 0.3);
  var modifiedStr = str * multiplier;
  var taskValue = getTaskValue(BACKSTAB_VERSION, BACKSTAB_TASK_VALUE, BACKSTAB_TASK_ID);
  var bonus = ( (taskValue + 1) + (modifiedStr * 0.5 ) )
  var newXp = xp + ( ( 75 * bonus ) / ( bonus + 50) );
  var newGp = gp + ( ( 18 * bonus ) / ( bonus + 75) );

  api_updateUser({"stats.gp" : newGp, "stats.exp" : newXp});
}

function stealth (totalDailies, prevStealthedDailies, per) {
  var newDailiesDodged = Math.ceil( ( 0.64 * totalDailies * ( per / (per + 55) ) ) );
  
  // If they'd Stealth more than total Dailies, instead only Stealth the total
  if ( ( prevStealthedDailies + newDailiesDodged ) >= totalDailies ) {
    api_updateUser({"stats.buffs.stealth" : totalDailies});
  }
  else {
    api_updateUser({"stats.buffs.stealth" : prevStealthedDailies + newDailiesDodged});
  }
}

function healingLight (hp, con, int) {
  var healing = ( ( con + int + 5 ) * 0.075 );
  if (hp + healing >= 50) {
    api_updateUser({"stats.hp" : 50});
  }
  else {
    api_updateUser({"stats.hp" : hp + healing});
  }
}

function chillingFrost(mp, mpCost) {
  api_updateUser({"stats.buffs.streaks" : true, "stats.mp" : mp - mpCost});
}

function burstOfFlamesXp(int, per, nTimes) {
  var taskValue = getTaskValue(BURST_OF_FLAMES_VERSION, BURST_OF_FLAMES_TASK_VALUE, BURST_OF_FLAMES_TASK_ID);
  var multiplier = 1;
  var modifiedInt = int;
  var bonus = 1;
  var newXpRunningTotal = 0;
  
  for ( var i = 1; i <= nTimes; i++) {
    multiplier = criticalHit(per, 0.03);
    modifiedInt = int * multiplier;
    var bonus = Math.ceil( (taskValue + 1) * (modifiedInt * 0.075 ) ) ;
    newXpRunningTotal += ( ( 75 * bonus ) / ( bonus + 37.5) );
  }
  
  return newXpRunningTotal;
}

// Expected and actual damage for Burst of Flames
function flamesDamage (int) {
  return Math.ceil(int/10);
}

// Expected damage for Brutal Smash. Since this is expected damage only (not actual), don't crit.
function smashDamageNoCrit (str) {
  return (55*str)/(str+70);
}

// Actual damage for Brutal Smash, including crit. Since there's a chance of crit at each iteration, loop through for each use of the skill rather than doing it once and multiplying by number of times
function smashDamageActual (str, con, nTimes) { 
  var smashRunningTotal = 0;
  var multiplier = 1;
  var modifiedStr = str;
  
  for ( var i = 1; i <= nTimes; i++) {
    multiplier = criticalHit(con, 0.03);
    modifiedStr = str * multiplier;
    smashRunningTotal += (55*modifiedStr)/(modifiedStr+70);
  }
  
  return smashRunningTotal;
}

// Expected damage for Radiant Shield. Since this is expected damage only (not actual), don't crit.
function radiantDamageNoCrit (con) {
  // CON above 225 has no additional in-game benefits elsewhere in Habitica (reducing damage from your own tasks), so I will cap damage here as well
  if (con > 225) {
    return 25;
  }
  else { // base damage of 10 ensure this skill isn't too weak at low levels
    return 10 + (con/15);
  }
}

// Actual damage for Radiant Shield, including crit. Since there's a chance of crit at each iteration, loop through for each use of the skill rather than doing it once and multiplying by number of times
function radiantDamageActual (con, int, nTimes) {
  var radiantRunningTotal = 0;
  var multiplier = 1;
  var modifiedCon = con;
  
  for ( var i = 1; i <= nTimes; i++) {
    multiplier = criticalHit(int, 0.03);
    modifiedCon = con * multiplier;
    if ( modifiedCon > 225) { // Max damage of 25 occurs at 225 CON. Since this is weaker than the other damage skills, the skill has a lower MP cost
      radiantRunningTotal += 25;
    }
    else { // based damage of 10 insurers it's not too weak at low levels
      radiantRunningTotal += ( 10 + (modifiedCon/15) );
    }
  }
  
  return radiantRunningTotal;
}

// Expected damage for Sneak Attack. Since this is expected damage only (not actual), don't crit.
function sneakDamageNoCrit (per) {
  // Goal: keep this skill as similar to Brutal Smash as possible.
  // Problem: Tools of the Trade buffs PER more than Valorous Presence buffs STR. So, it can't be swap of PER = STR.
  // Solution: scale damage based on how many buffs it takes. Keep it the same formula up to 35 damage (112.5 STR/PER).
    // Based on Brutal Smash / Valorous Presence, 16 buffs goes from 35 to 45 damage, 32 further buffs to go from 45 to 50 damage.
  
  // Up to 35 damage (PER = 122.5), Sneak Attack is identical to Brutal Smash
  if (per <= 122.5) {
    return (55 * per) / (per + 70);
  }
  // 35 damage from the previous "tier" formula rolls over, then aim to be at 45 total damage at 1486 PER
  else if ( (per > 122.5) && (per <= 1486) ) {
    return 35 + (20 * per) / (per + 1486);
  }
  // 45 damage from the previous "tier" formula rolls over, then aim to be at 50 total damage at 4213 PER
  else if (per > 1486) {
    return 45 + (10 * per) / (per + 4213);
  }
  else { // this scenario shouldn't be possible, but just in case…
    api_sendPrivateMessage({"message" : "Error calculating Sneak Attack damage, please contact the creator of this script so he can debug.", "toUserId" : USER_ID});
  }
}

// Actual damage for Sneak Attack, including crit. Since there's a chance of crit at each iteration, loop through for each use of the skill rather than doing it once and multiplying by number of times
function sneakDamageActual (per, str, nTimes) { 
  var sneakRunningTotal = 0;
  var multiplier = 1;
  var modifiedPer = per;
  
  for ( var i = 1; i <= nTimes; i++) {
    multiplier = criticalHit(str, 0.03);
    modifiedPer = per * multiplier;
    
    // Instead of using PER for the cutoff points, use modifiedPer because it's PER times crit multiplier
    if (modifiedPer <= 122.5) {
      sneakRunningTotal += (55*modifiedPer)/(modifiedPer+70);
    }
    else if ( (modifiedPer > 122.5) && (modifiedPer <= 1486) ) {
      sneakRunningTotal += 35 + ( (20*modifiedPer)/(modifiedPer+1486) );
    }
    else if (modifiedPer > 1486) {
      sneakRunningTotal += 45 + ( (10*modifiedPer)/(modifiedPer+4213) );
    }
  }
  
  return sneakRunningTotal;
}

// Deals boss damage
function doDamage(damage, mpCost, nTimes, unbuffedStr, unbuffedInt, unbuffedPer, buffsStr, buffsInt, buffsPer, hp, xp, mp, gp, lvl, isFlamesXp, valueToChange) {
  var totalMpCost = mpCost * nTimes;
  
  // calculate STR setpoint needed to achieve expected damage. Damage = (1+(STR*0.005)) * (1.5 + ((4*STR)/(200+STR)) ) * 1, since crit is 100% guaranteed and task value delta resolves to 1
  // lowest STR setpoint is 3244, which guarantees a crit, for 90.71 damage. Highest setpoint is 6500, for 180.25 damage, since that's the most this script will do in one use.
  var setpoint = setpointIteration(3244, 6500, damage);
  
  // Create one To-Do so I can check it off in order to do damage
  api_createNewTaskForUser(DAMAGE_BUTTON);
        
  // pause for 1 second
  Utilities.sleep(1000);
        
  // buff STR up to setpoint, INT and PER down to 1
  api_updateUser({"stats.buffs.str" : setpoint - unbuffedStr, "stats.buffs.int" : 1 - unbuffedInt, "stats.buffs.per" : 1 - unbuffedPer});
        
  // pause for 1 second
  Utilities.sleep(1000);
        
  // check off the To-Do created
  const responseTask = api_getUserTasks("todos");
  const tasksForDamage = JSON.parse(responseTask).data;
  var taskIdForDamage = "";
  
  // loop through all To-Do's, see which one matches Text and Notes for the previously-created Damage Button
  for (var j in tasksForDamage) { 
    if ( (tasksForDamage[j].text == DAMAGE_TEXT) && (tasksForDamage[j].notes == DAMAGE_NOTES) ) {
      taskIdForDamage = tasksForDamage[j]._id; // if it's a match, save ID of the task since that's the easiest way for me to grab it
      api_scoreTask(taskIdForDamage, "up"); // this is the task for me to score
    }
  }
        
  // reset values back to their original ones, including FCV-able ones that may have changed. Deduct mana cost also
  // if XP needs to increase (Burst of Flames), do this in this step also
  if (isFlamesXp) {
    api_updateUser({"stats.buffs.str" : buffsStr, "stats.buffs.int" : buffsInt, "stats.buffs.per" : buffsPer,
                    "stats.hp" : hp, "stats.exp" : xp + valueToChange, "stats.mp" : mp - totalMpCost, "stats.gp" : gp, "stats.lvl" : lvl});
  }
  else {
    api_updateUser({"stats.buffs.str" : buffsStr, "stats.buffs.int" : buffsInt, "stats.buffs.per" : buffsPer,
                    "stats.hp" : hp, "stats.exp" : xp, "stats.mp" : mp - totalMpCost, "stats.gp" : gp, "stats.lvl" : lvl});
  }
}

// calculate setpoint, inputting a low guess and a high guess
function setpointIteration (low, high, targetDamage) {
  var midpoint = Math.floor(((low+high)/2));
  
  // damage at each setpoint
  var damageLow = damageAtSetpoint(low);
  var damageMidpoint = damageAtSetpoint(midpoint);
  var damageHigh = damageAtSetpoint(high);
  
  // truth conditions regarding damage and where it falls (compared to the setpoints)
  var targetAboveLow = (damageLow < targetDamage) ? true : false;
  var targetAboveMidpoint = (damageMidpoint < targetDamage) ? true : false;
  var targetBelowHigh = (damageHigh > targetDamage) ? true : false;
  
  // if these values are within 2 of each other, iteration is done
  if ( ( high - low ) <= 2) {
    // whichever setpoint exceeds target damage is our setpoint
    if (!targetAboveLow) {
      return low;
    }
    else if (!targetAboveMidpoint) {
      return midpoint;
    }
    else if (targetBelowHigh) {
      return high;
    }
    else { // This condition shouldn't be possible, but just in case…
      api_sendPrivateMessage({"message" : "Error computing damage. Please contact the creator of the script to debug (note to creator: final iteration triggered this message).", "toUserId" : USER_ID});
    }
  }
  else { // keep iterating
    // Confirm target is between high and low
    if (targetAboveLow && targetBelowHigh) {
      // is it above or below midpoint? If above it, run it again but with midpoint and high being the new low/high, else run it with mid/low being new low/high
      if (targetAboveMidpoint) {
        return setpointIteration (midpoint, high, targetDamage);
      }
      else {
        return setpointIteration (low, midpoint, targetDamage);
      }
    }
    else { // if it's not between low and high, something messed up. This condition shouldn't be possible, but just in case…
      api_sendPrivateMessage({"message" : "Error computing damage. Please contact the creator of the script to debug (note to creator: target damage not between low and high setpoints).", "toUserId" : USER_ID});
    }
  }
}

// calculate damage for checking off one task at a given value of STR
function damageAtSetpoint (str) {
  return (1+(str*0.005)) * (1.5 + ((4*str)/(200+str)) );
}

function api_getUserTasks(type) {
  const params = {
    "method" : "get",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }
  
  var url = "https://habitica.com/api/v3/tasks/user";
  if (type != "") {
    url += "?type=" + type;
  }

  return UrlFetchApp.fetch(url, params);
}

// Score a task
function api_scoreTask(aliasOrId, direction) {
  var params = {
    "method" : "post",
    "headers" : HEADERS,
    "muteHttpExceptions" : true,
  }

  var url = "https://habitica.com/api/v3/tasks/";
  if ( (aliasOrId != "") && (direction != "") ) {
    url += aliasOrId + "/score/" + direction;
  }
  return UrlFetchApp.fetch(url, params);
}
